ls
# DUT_tb.sv
# funcSim.do
# modelsim.ini
# transcript
# vsim.wlf
# wave.do
# work
do funcSim.do
# @0 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:18:17 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:18:17 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:18:17 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:18:17 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:18:17 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:19:42 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:19:42 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:19:42 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:19:42 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:19:43 on May 14,2022, Elapsed time: 0:01:26
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:19:43 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 85
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:20:42 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:20:42 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:20:42 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:20:42 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:20:42 on May 14,2022, Elapsed time: 0:00:59
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:20:42 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 85
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:24:19 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:24:19 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:24:19 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:24:19 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work -do "${TB_MOD} params"
# No design specified
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @600 ns: =============================================================
# printTxt $string
# @600 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @600 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 85
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 91
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 97
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 35ns
# Executing ONERROR command at macro ./funcSim.do line 99
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 40ns
# Executing ONERROR command at macro ./funcSim.do line 101
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# Time value must be greater than "now": 200ns
# Executing ONERROR command at macro ./funcSim.do line 108
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @610 ns: =============================================================
# printTxt $string
# @610 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @610 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @610 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 123
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 124
# run {@210ns}
# Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 125
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @610 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 133
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 134
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 135
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 136
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 137
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 138
# run {@250ns}
# Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 139
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @610 ns: =============================================================
# printTxt $string
# @610 ns: Running simulation for multiplication
# printTxt $separator
# @610 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 150
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 151
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# ** Error: Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 152
# run {@280ns}
# Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 153
# printTxt "simple case"
# @610 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 155
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 156
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 157
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 159
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 160
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 161
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 162
# printTxt "simple case"
# @610 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 164
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 165
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 166
# run {@375ns}
# Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 167
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# Time value must be greater than "now": 420ns
# Executing ONERROR command at macro ./funcSim.do line 170
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @610 ns: =============================================================
# printTxt $string
# @610 ns: Running simulation for division
# printTxt $separator
# @610 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# Time value must be greater than "now": 430ns
# Executing ONERROR command at macro ./funcSim.do line 184
# printTxt "simple case"
# @610 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 188
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 189
# run {@510ns}
# Time value must be greater than "now": 510ns
# Executing ONERROR command at macro ./funcSim.do line 190
# printTxt "complex case"
# @610 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
# Time value must be greater than "now": 600ns
# Executing ONERROR command at macro ./funcSim.do line 194
do funcSim.do 0
# @610 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:25:30 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:25:30 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:25:30 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:25:30 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work -c -do "${TB_MOD}.sv params"
# No design specified
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @610 ns: =============================================================
# printTxt $string
# @610 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @610 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 85
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 91
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 97
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 35ns
# Executing ONERROR command at macro ./funcSim.do line 99
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 40ns
# Executing ONERROR command at macro ./funcSim.do line 101
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# Time value must be greater than "now": 200ns
# Executing ONERROR command at macro ./funcSim.do line 108
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @620 ns: =============================================================
# printTxt $string
# @620 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @620 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @620 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 123
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 124
# run {@210ns}
# Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 125
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @620 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 133
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 134
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 135
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 136
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 137
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 138
# run {@250ns}
# Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 139
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @620 ns: =============================================================
# printTxt $string
# @620 ns: Running simulation for multiplication
# printTxt $separator
# @620 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 150
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 151
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# ** Error: Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 152
# run {@280ns}
# Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 153
# printTxt "simple case"
# @620 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 155
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 156
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 157
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 159
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 160
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 161
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 162
# printTxt "simple case"
# @620 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 164
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 165
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 166
# run {@375ns}
# Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 167
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# Time value must be greater than "now": 420ns
# Executing ONERROR command at macro ./funcSim.do line 170
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @620 ns: =============================================================
# printTxt $string
# @620 ns: Running simulation for division
# printTxt $separator
# @620 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# Time value must be greater than "now": 430ns
# Executing ONERROR command at macro ./funcSim.do line 184
# printTxt "simple case"
# @620 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 188
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 189
# run {@510ns}
# Time value must be greater than "now": 510ns
# Executing ONERROR command at macro ./funcSim.do line 190
# printTxt "complex case"
# @620 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
# Time value must be greater than "now": 600ns
# Executing ONERROR command at macro ./funcSim.do line 194
do funcSim.do 0
# @620 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:30:04 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:30:04 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:30:04 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:30:04 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work -c -do "${TB_MOD}.sv params"
# No design specified
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @620 ns: =============================================================
# printTxt $string
# @620 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @620 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argv": no such variable
# Executing ONERROR command at macro ./funcSim.do line 90
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 96
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 102
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 35ns
# Executing ONERROR command at macro ./funcSim.do line 104
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 40ns
# Executing ONERROR command at macro ./funcSim.do line 106
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# Time value must be greater than "now": 200ns
# Executing ONERROR command at macro ./funcSim.do line 113
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @630 ns: =============================================================
# printTxt $string
# @630 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @630 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @630 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 128
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 129
# run {@210ns}
# Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 130
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @630 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 138
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 139
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 140
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 141
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 142
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 143
# run {@250ns}
# Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 144
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @630 ns: =============================================================
# printTxt $string
# @630 ns: Running simulation for multiplication
# printTxt $separator
# @630 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 155
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 156
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# ** Error: Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 157
# run {@280ns}
# Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 158
# printTxt "simple case"
# @630 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 160
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 161
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 162
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 164
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 165
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 166
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 167
# printTxt "simple case"
# @630 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 169
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 170
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 171
# run {@375ns}
# Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 172
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# Time value must be greater than "now": 420ns
# Executing ONERROR command at macro ./funcSim.do line 175
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @630 ns: =============================================================
# printTxt $string
# @630 ns: Running simulation for division
# printTxt $separator
# @630 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# Time value must be greater than "now": 430ns
# Executing ONERROR command at macro ./funcSim.do line 189
# printTxt "simple case"
# @630 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 193
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 194
# run {@510ns}
# Time value must be greater than "now": 510ns
# Executing ONERROR command at macro ./funcSim.do line 195
# printTxt "complex case"
# @630 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
# Time value must be greater than "now": 600ns
# Executing ONERROR command at macro ./funcSim.do line 199
do funcSim.do 0
# @630 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:31:36 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:31:36 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:31:36 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:31:36 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work -c -do "${TB_MOD}.sv params"
# No design specified
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @630 ns: =============================================================
# printTxt $string
# @630 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @630 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "1": no such variable
# Executing ONERROR command at macro ./funcSim.do line 93
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 99
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 105
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 35ns
# Executing ONERROR command at macro ./funcSim.do line 107
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 40ns
# Executing ONERROR command at macro ./funcSim.do line 109
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# Time value must be greater than "now": 200ns
# Executing ONERROR command at macro ./funcSim.do line 116
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @640 ns: =============================================================
# printTxt $string
# @640 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @640 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @640 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 131
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 132
# run {@210ns}
# Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 133
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @640 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 141
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 142
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 143
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 144
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 145
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 146
# run {@250ns}
# Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 147
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @640 ns: =============================================================
# printTxt $string
# @640 ns: Running simulation for multiplication
# printTxt $separator
# @640 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 158
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 159
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# ** Error: Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 160
# run {@280ns}
# Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 161
# printTxt "simple case"
# @640 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 163
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 164
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 165
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 167
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 168
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 169
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 170
# printTxt "simple case"
# @640 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 172
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 173
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 174
# run {@375ns}
# Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 175
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# Time value must be greater than "now": 420ns
# Executing ONERROR command at macro ./funcSim.do line 178
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @640 ns: =============================================================
# printTxt $string
# @640 ns: Running simulation for division
# printTxt $separator
# @640 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# Time value must be greater than "now": 430ns
# Executing ONERROR command at macro ./funcSim.do line 192
# printTxt "simple case"
# @640 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 196
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 197
# run {@510ns}
# Time value must be greater than "now": 510ns
# Executing ONERROR command at macro ./funcSim.do line 198
# printTxt "complex case"
# @640 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
# Time value must be greater than "now": 600ns
# Executing ONERROR command at macro ./funcSim.do line 202
do funcSim.do 0
# @640 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:32:36 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:32:36 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:32:36 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:32:36 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work -c -do "${TB_MOD}.sv params"
# No design specified
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @640 ns: =============================================================
# printTxt $string
# @640 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @640 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
#getArgs
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 99
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 30ns
# Executing ONERROR command at macro ./funcSim.do line 105
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 35ns
# Executing ONERROR command at macro ./funcSim.do line 107
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# ** Error: Time value must be greater than "now": 40ns
# Executing ONERROR command at macro ./funcSim.do line 109
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# Time value must be greater than "now": 200ns
# Executing ONERROR command at macro ./funcSim.do line 116
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @650 ns: =============================================================
# printTxt $string
# @650 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @650 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @650 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 131
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# ** Error: Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 132
# run {@210ns}
# Time value must be greater than "now": 210ns
# Executing ONERROR command at macro ./funcSim.do line 133
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @650 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 141
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# ** Error: Time value must be greater than "now": 220ns
# Executing ONERROR command at macro ./funcSim.do line 142
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 143
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# ** Error: Time value must be greater than "now": 230ns
# Executing ONERROR command at macro ./funcSim.do line 144
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 145
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# ** Error: Time value must be greater than "now": 240ns
# Executing ONERROR command at macro ./funcSim.do line 146
# run {@250ns}
# Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 147
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @650 ns: =============================================================
# printTxt $string
# @650 ns: Running simulation for multiplication
# printTxt $separator
# @650 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 158
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# ** Error: Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 159
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# ** Error: Time value must be greater than "now": 250ns
# Executing ONERROR command at macro ./funcSim.do line 160
# run {@280ns}
# Time value must be greater than "now": 280ns
# Executing ONERROR command at macro ./funcSim.do line 161
# printTxt "simple case"
# @650 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 163
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# ** Error: Time value must be greater than "now": 320ns
# Executing ONERROR command at macro ./funcSim.do line 164
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 165
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 167
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 168
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# ** Error: Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 169
# run {@350ns}
# Time value must be greater than "now": 350ns
# Executing ONERROR command at macro ./funcSim.do line 170
# printTxt "simple case"
# @650 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 172
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 173
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# ** Error: Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 174
# run {@375ns}
# Time value must be greater than "now": 375ns
# Executing ONERROR command at macro ./funcSim.do line 175
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# Time value must be greater than "now": 420ns
# Executing ONERROR command at macro ./funcSim.do line 178
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @650 ns: =============================================================
# printTxt $string
# @650 ns: Running simulation for division
# printTxt $separator
# @650 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# Time value must be greater than "now": 430ns
# Executing ONERROR command at macro ./funcSim.do line 192
# printTxt "simple case"
# @650 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 196
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# ** Error: Time value must be greater than "now": 450ns
# Executing ONERROR command at macro ./funcSim.do line 197
# run {@510ns}
# Time value must be greater than "now": 510ns
# Executing ONERROR command at macro ./funcSim.do line 198
# printTxt "complex case"
# @650 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
# Time value must be greater than "now": 600ns
# Executing ONERROR command at macro ./funcSim.do line 202
do funcSim.do 0
# @650 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:33:54 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:33:54 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:33:54 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:33:54 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:33:54 on May 14,2022, Elapsed time: 0:13:12
# Errors: 125, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:33:54 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
#getArgs
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:34:32 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:34:32 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:34:32 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:34:32 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:34:32 on May 14,2022, Elapsed time: 0:00:38
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:34:32 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "1": no such variable
# Executing ONERROR command at macro ./funcSim.do line 93
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0 1 2
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:36:17 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:36:17 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:36:17 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:36:17 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:36:17 on May 14,2022, Elapsed time: 0:01:45
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:36:17 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
#getArgs
# printTxt $1
# @10 ns: 0
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0 1 2
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:37:25 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:37:25 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:37:25 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:37:25 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:37:26 on May 14,2022, Elapsed time: 0:01:09
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:37:26 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: --
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:38:11 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:38:11 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:38:11 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:38:11 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:38:11 on May 14,2022, Elapsed time: 0:00:45
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:38:11 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: --
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:42:47 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:42:47 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:42:47 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:42:47 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:42:48 on May 14,2022, Elapsed time: 0:04:37
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:42:48 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 119
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:42:58 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:42:58 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:42:58 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:42:58 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:42:58 on May 14,2022, Elapsed time: 0:00:10
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:42:58 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 119
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0 1 2
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:43:09 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:43:09 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:43:09 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:43:09 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:43:09 on May 14,2022, Elapsed time: 0:00:11
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:43:09 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 119
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0 1 2
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:43:30 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:43:30 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:43:30 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:43:30 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:43:31 on May 14,2022, Elapsed time: 0:00:22
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:43:31 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 120
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0 1 2
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:46:13 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:46:13 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:46:13 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:46:13 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:46:14 on May 14,2022, Elapsed time: 0:02:43
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:46:14 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "argc": no such variable
# Executing ONERROR command at macro ./funcSim.do line 118
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 0 1 2
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:46:52 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:46:52 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:46:52 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:46:52 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:46:53 on May 14,2022, Elapsed time: 0:00:39
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:46:53 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: 1 
# 
# @10 ns: arg 2: 2 
# 
# @10 ns: arg 3: 3 
# 
# @10 ns: arg 4: 4 
# 
# @10 ns: arg 5: 5 
# 
# @10 ns: arg 6: 6 
# 
# @10 ns: arg 7: 7 
# 
# @10 ns: arg 8: 8 
# 
# @10 ns: arg 9: 9 
# 
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:47:36 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:47:36 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:47:36 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:47:36 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:47:37 on May 14,2022, Elapsed time: 0:00:44
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:47:37 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: 1 
# 
# @10 ns: arg 2: 2 
# 
# @10 ns: arg 3: 3 
# 
# @10 ns: arg 4: 4 
# 
# @10 ns: arg 5: 5 
# 
# @10 ns: arg 6: 6 
# 
# @10 ns: arg 7: 7 
# 
# @10 ns: arg 8: 8 
# 
# @10 ns: arg 9: 9 
# 
#printTxt $1
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:48:01 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:48:01 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:48:01 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:48:01 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:48:01 on May 14,2022, Elapsed time: 0:00:24
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:48:01 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: 1 
# 
# @10 ns: arg 2: 2 
# 
# @10 ns: arg 3: 3 
# 
# @10 ns: arg 4: 4 
# 
# @10 ns: arg 5: 5 
# 
# @10 ns: arg 6: 6 
# 
# @10 ns: arg 7: 7 
# 
# @10 ns: arg 8: 8 
# 
# @10 ns: arg 9: 9 
# 
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:49:07 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:49:07 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:49:07 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:49:07 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:49:08 on May 14,2022, Elapsed time: 0:01:07
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:49:08 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "$i": no such variable
# Executing ONERROR command at macro ./funcSim.do line 114
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:50:11 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:50:11 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:50:11 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:50:11 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:50:12 on May 14,2022, Elapsed time: 0:01:04
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:50:12 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "${i": no such variable
# Executing ONERROR command at macro ./funcSim.do line 114
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:50:40 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:50:41 on May 14,2022, Elapsed time: 0:00:01
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:50:41 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:50:41 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:50:41 on May 14,2022, Elapsed time: 0:00:29
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:50:41 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: $1 
# 
# @10 ns: arg 2: $2 
# 
# @10 ns: arg 3: $3 
# 
# @10 ns: arg 4: $4 
# 
# @10 ns: arg 5: $5 
# 
# @10 ns: arg 6: $6 
# 
# @10 ns: arg 7: $7 
# 
# @10 ns: arg 8: $8 
# 
# @10 ns: arg 9: $9 
# 
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:51:45 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:51:45 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:51:45 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:51:45 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:51:46 on May 14,2022, Elapsed time: 0:01:05
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:51:46 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "$i": no such variable
# Executing ONERROR command at macro ./funcSim.do line 115
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:59:23 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 13:59:23 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 13:59:23 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 13:59:23 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 13:59:24 on May 14,2022, Elapsed time: 0:07:38
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 13:59:24 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "${i": no such variable
# Executing ONERROR command at macro ./funcSim.do line 115
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:00:06 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:00:06 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:00:06 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:00:06 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 14:00:07 on May 14,2022, Elapsed time: 0:00:43
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:00:07 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: $1
# @10 ns: arg 2: $2
# @10 ns: arg 3: $3
# @10 ns: arg 4: $4
# @10 ns: arg 5: $5
# @10 ns: arg 6: $6
# @10 ns: arg 7: $7
# @10 ns: arg 8: $8
# @10 ns: arg 9: $9
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:04:34 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:04:34 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:04:34 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:04:34 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 14:04:34 on May 14,2022, Elapsed time: 0:04:27
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:04:34 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: $1
# @10 ns: arg 2: $2
# @10 ns: arg 3: $3
# @10 ns: arg 4: $4
# @10 ns: arg 5: $5
# @10 ns: arg 6: $6
# @10 ns: arg 7: $7
# @10 ns: arg 8: $8
# @10 ns: arg 9: $9
# @10 ns: argv
# @10 ns: argc
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:08:21 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:08:21 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:08:21 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:08:21 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 14:08:22 on May 14,2022, Elapsed time: 0:03:48
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:08:22 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: 1
# @10 ns: arg 2: 2
# @10 ns: arg 3: 3
# @10 ns: arg 4: 4
# @10 ns: arg 5: 5
# @10 ns: arg 6: 6
# @10 ns: arg 7: 7
# @10 ns: arg 8: 8
# @10 ns: arg 9: 9
# @10 ns: argv
# @10 ns: argc
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:09:26 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:09:26 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:09:26 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:09:26 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 14:09:27 on May 14,2022, Elapsed time: 0:01:05
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:09:27 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: i
# @10 ns: arg 2: i
# @10 ns: arg 3: i
# @10 ns: arg 4: i
# @10 ns: arg 5: i
# @10 ns: arg 6: i
# @10 ns: arg 7: i
# @10 ns: arg 8: i
# @10 ns: arg 9: i
# @10 ns: argv
# @10 ns: argc
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:09:57 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:09:57 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:09:57 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:09:57 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD}
# End time: 14:09:57 on May 14,2022, Elapsed time: 0:00:30
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:09:57 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "$i": no such variable
# Executing ONERROR command at macro ./funcSim.do line 121
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:28:10 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:28:10 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:28:10 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:28:10 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} -do "T1 T2 T3"
# End time: 14:28:11 on May 14,2022, Elapsed time: 0:18:14
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb -do "T1 T2 T3" 
# Start time: 14:28:11 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# T1 T2 T3
# invalid command name "T1"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: can't read "$i": no such variable
# Executing ONERROR command at macro ./funcSim.do line 121
# printTxt $1
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
T1 T2 T3
# invalid command name "T1"
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:28:56 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:28:57 on May 14,2022, Elapsed time: 0:00:01
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:28:57 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:28:57 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} -do "T1 T2 T3"
# End time: 14:28:57 on May 14,2022, Elapsed time: 0:00:46
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb -do "T1 T2 T3" 
# Start time: 14:28:57 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# T1 T2 T3
# invalid command name "T1"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: 1
# @10 ns: arg 2: 2
# @10 ns: arg 3: 3
# @10 ns: arg 4: 4
# @10 ns: arg 5: 5
# @10 ns: arg 6: 6
# @10 ns: arg 7: 7
# @10 ns: arg 8: 8
# @10 ns: arg 9: 9
# @10 ns: argv
# @10 ns: argc
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
vsim -do "funcSim.do T1 T2 T3"
# No design specified
vsim -do "<funcSim.do> T1 T2 T3"
# No design specified
vsim -do "<funcSim.do> T1 T2 T3"
# No design specified
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:32:26 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:32:26 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:32:26 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:32:26 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} -do "T1 T2 T3"
# End time: 14:32:26 on May 14,2022, Elapsed time: 0:03:29
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb -do "T1 T2 T3" 
# Start time: 14:32:26 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# T1 T2 T3
# invalid command name "T1"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: arg 1: 1
# @10 ns: arg 2: 2
# @10 ns: arg 3: 3
# @10 ns: arg 4: 4
# @10 ns: arg 5: 5
# @10 ns: arg 6: 6
# @10 ns: arg 7: 7
# @10 ns: arg 8: 8
# @10 ns: arg 9: 9
# @10 ns: argv
# @10 ns: argc
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:34:05 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:34:05 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:34:05 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:34:05 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} -do "T1 T2 T3"
# End time: 14:34:06 on May 14,2022, Elapsed time: 0:01:40
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb -do "T1 T2 T3" 
# Start time: 14:34:06 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# T1 T2 T3
# invalid command name "T1"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# ** Error: invalid command name "else"
# Executing ONERROR command at macro ./funcSim.do line 122
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:36:12 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:36:12 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:36:12 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:36:12 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} -do "T1 T2 T3"
# End time: 14:36:13 on May 14,2022, Elapsed time: 0:02:07
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb -do "T1 T2 T3" 
# Start time: 14:36:13 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# T1 T2 T3
# invalid command name "T1"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: --
# @10 ns: 
# @10 ns: 
# @10 ns: argv
# @10 ns: argc
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:38:14 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:38:14 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:38:14 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:38:14 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} -do "T1 T2 T3"
# End time: 14:38:15 on May 14,2022, Elapsed time: 0:02:02
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb -do "T1 T2 T3" 
# Start time: 14:38:15 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# T1 T2 T3
# invalid command name "T1"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: --
# @10 ns: argv
# @10 ns: argc
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:39:57 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:39:58 on May 14,2022, Elapsed time: 0:00:01
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:39:58 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:39:58 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} -do "T1 T2 T3"
# End time: 14:39:58 on May 14,2022, Elapsed time: 0:01:43
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb -do "T1 T2 T3" 
# Start time: 14:39:58 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# T1 T2 T3
# invalid command name "T1"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: --
# @10 ns: --
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
# @600 ns: .
# .
# DUT_tb
# alu_simple_bugs_enc2
# =============================================================
# Running functional simulation of 
# Running functional simulation of alu_simple_bugs_enc2
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:40:42 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:40:42 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:40:42 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:40:42 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} # -do "T1 T2 T3"
# End time: 14:40:42 on May 14,2022, Elapsed time: 0:00:44
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb # -do "T1 T2 T3" 
# Start time: 14:40:42 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# ** Error: (vsim-3170) Could not find '#'.
#         Searched libraries:
#             /home/ubuintu/Documents/Verilog/SystemVerilog/ALU/LinearTB/work
# Error loading design
# Error: Error loading design
#        Pausing macro execution
# MACRO ./funcSim.do PAUSED at line 107
do funcSim.do 5 5 5
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt $arg
#         }
# 
#         printTxt $argv
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG $i
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @0 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:41:17 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:41:17 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:41:17 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:41:17 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:40:42 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: --
# @10 ns: --
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt $arg
#         }
# 
#         printTxt $argv
#         puts $argv
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG $i
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:44:13 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:44:13 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:44:13 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:44:13 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:44:13 on May 14,2022, Elapsed time: 0:03:31
# Errors: 1, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:44:13 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: --
# @10 ns: --
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt $arg
#         }
# 
#         printTxt $argv
#         puts $argv
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG $i
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:45:50 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:45:50 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:45:50 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:45:50 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:45:51 on May 14,2022, Elapsed time: 0:01:38
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:45:51 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: No arguements entered
# printTxt $1
# ** Error: can't read "1": no such variable
# Executing ONERROR command at macro ./funcSim.do line 131
# printTxt $2
# ** Error: can't read "2": no such variable
# Executing ONERROR command at macro ./funcSim.do line 132
# printTxt $argc
# @10 ns: 0
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
# 
#         printTxt "argv is: $argv"
#         puts $argv
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG $i
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:47:50 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:47:50 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:47:50 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:47:50 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:47:51 on May 14,2022, Elapsed time: 0:02:00
# Errors: 2, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:47:51 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: No arguements entered
# printTxt $1
# ** Error: can't read "1": no such variable
# Executing ONERROR command at macro ./funcSim.do line 132
# printTxt $2
# ** Error: can't read "2": no such variable
# Executing ONERROR command at macro ./funcSim.do line 133
# printTxt $argc
# @10 ns: 0
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
# 
#         printTxt "argv is: $argv"
#         puts $argv
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG $i
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:48:13 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:48:13 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:48:13 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:48:13 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:48:14 on May 14,2022, Elapsed time: 0:00:23
# Errors: 2, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:48:14 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: argv is: --
# printTxt $1
# @10 ns: 5
# printTxt $2
# @10 ns: 5
# printTxt $argc
# @10 ns: 3
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 5 5 5
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
# 
#         switch $argc {
#             1 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#             }
#             2 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#             }
#             3 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#                 printTxt "Arg3: $3"
#             }
#         }
# 
#         printTxt "argv is: $argv"
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG ${$i}
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:52:06 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:52:06 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:52:06 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:52:06 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:52:07 on May 14,2022, Elapsed time: 0:03:53
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:52:07 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: Inside switch statement
# @10 ns: Arg1: 5
# @10 ns: Arg2: 5
# @10 ns: Arg3: 5
# @10 ns: argv is: --
#printTxt $1
#printTxt $2
#printTxt $argc
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 4 5 6
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
# 
#         switch $argc {
#             1 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#             }
#             2 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#             }
#             3 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#                 printTxt "Arg3: $3"
#             }
#         }
# 
#         printTxt "argv is: $argv"
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG ${$i}
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:52:22 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:52:22 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:52:22 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:52:22 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:52:23 on May 14,2022, Elapsed time: 0:00:16
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:52:23 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: Inside switch statement
# @10 ns: Arg1: 4
# @10 ns: Arg2: 5
# @10 ns: Arg3: 6
# @10 ns: argv is: --
#printTxt $1
#printTxt $2
#printTxt $argc
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 4 5 6
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
#         
#         # Modelsim does not allow argv simulator state variable, see microsemi doc
#         switch $argc {
#             1 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#             }
#             2 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#             }
#             3 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#                 printTxt "Arg3: $3"
#             }
#         }
# 
#         printTxt "argv is: $argv"
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG ${$i}
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:57:40 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:57:40 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:57:40 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:57:41 on May 14,2022, Elapsed time: 0:00:01
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:57:41 on May 14,2022, Elapsed time: 0:05:18
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:57:41 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: Inside switch statement
# @10 ns: Arg1: 4
# @10 ns: Arg2: 5
# @10 ns: Arg3: 6
# @10 ns: argv is: --
# printTxt $architecture
# @10 ns: 
#printTxt $1
#printTxt $2
#printTxt $argc
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 4 5 6
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
#         
#         # Modelsim does not allow argv simulator state variable, see microsemi doc
#         switch $argc {
#             1 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#             }
#             2 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#             }
#             3 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#                 printTxt "Arg3: $3"
#             }
#         }
# 
#         printTxt "argv is: $argv"
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG ${$i}
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:58:12 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:58:12 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:58:12 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:58:12 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:58:13 on May 14,2022, Elapsed time: 0:00:32
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:58:13 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: Inside switch statement
# @10 ns: Arg1: 4
# @10 ns: Arg2: 5
# @10 ns: Arg3: 6
# @10 ns: argv is: --
# printTxt $architecture
# @10 ns: 
#printTxt $1
#printTxt $2
#printTxt $argc
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 4 5 6
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
#         
#         # Modelsim does not allow argv simulator state variable, see microsemi doc
#         switch $argc {
#             1 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#             }
#             2 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#             }
#             3 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#                 printTxt "Arg3: $3"
#             }
#         }
# 
#         printTxt "argv is: $argv"
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG ${$i}
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:59:33 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 14:59:33 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 14:59:33 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 14:59:33 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 14:59:33 on May 14,2022, Elapsed time: 0:01:20
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 14:59:33 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: Inside switch statement
# @10 ns: Arg1: 4
# @10 ns: Arg2: 5
# @10 ns: Arg3: 6
# @10 ns: argv is: --
# printTxt $architecture
# @10 ns: 
# printTxt $configuration
# @10 ns: 
#printTxt $1
#printTxt $2
#printTxt $argc
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 4 5 6
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
#         
#         # Modelsim does not allow argv simulator state variable, see microsemi doc
#         switch $argc {
#             1 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#             }
#             2 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#             }
#             3 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#                 printTxt "Arg3: $3"
#             }
#         }
# 
#         printTxt "argv is: $argv"
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG ${$i}
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 15:00:33 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 15:00:33 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 15:00:33 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 15:00:33 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# End time: 15:00:33 on May 14,2022, Elapsed time: 0:01:00
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 15:00:33 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: Inside switch statement
# @10 ns: Arg1: 4
# @10 ns: Arg2: 5
# @10 ns: Arg3: 6
# @10 ns: argv is: --
# printTxt $architecture
# @10 ns: 
# printTxt $configuration
# @10 ns: 
# printTxt $entity
# @10 ns: DUT_tb
#printTxt $1
#printTxt $2
#printTxt $argc
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
do funcSim.do 4 5 6
####################################
# Procedure 
####################################
# proc printTxt {msg} {
#     global now      #creates local variable linked to correponding global variables
#     global UNITS    # note that UNITS can be accessed outside proc call 
#     set UNITS ns
#     echo @${now} ${UNITS}: $msg
#     puts "@${now} ${UNITS}: ${msg}"
# }
# 
# proc getScriptDirectory {} {
#     set dispScriptFile [file normalize [info script]]
#     set scriptFolder [file dirname $dispScriptFile]
#     printTxt $scriptFolder
#     return $scriptFolder
# }
# 
# proc getArgs {} {
#     global argv
#     global 1
#     global 2
#     global 3
#     global 4
#     global 5
#     global argc
# 
#     # WIP; argc doesnt exist
#     set MSG "No arguements entered"
#     if {$argc==0} {
#         printTxt $MSG
#     } else {
# 
#         set MSG "Number of arguments: "
#         append MSG $argc
#         append MSG "\nArguments are: "
#         printTxt $MSG
# 
#         # Currently doesn't work
#        for {set i 0} {$i < $argc} {incr i} {
#             printTxt [lindex $argv $i]              
#        }
# 
#         foreach arg $argv {
#             printTxt "inside foreach"
#             printTxt $arg
#         }
#         
#         # Modelsim does not allow argv simulator state variable, see microsemi doc
#         switch $argc {
#             1 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#             }
#             2 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#             }
#             3 {
#                 printTxt "Inside switch statement"
#                 printTxt "Arg1: $1"
#                 printTxt "Arg2: $2"
#                 printTxt "Arg3: $3"
#             }
#         }
# 
#         printTxt "argv is: $argv"
#     }
# 
#     # Same as above only using $1-9 & argv
#    set MSG "No arguements entered"
#    #issue w/argv
#    puts [llength $argv]
#    puts $argv
#
#
#        for {set i 1} {$i < 10} {incr i} {
#             set MSG  "arg $i: "              
#             append MSG ${$i}
#             printTxt $MSG
#        }
#     
# 
#     # works w/global declaration
#    foreach arg $argv {
#        printTxt $arg
#    }
# 
#    set argv $::argv
#    set argc $::argc
#
#    printTxt argv
#    printTxt argc
# 
#    printTxt $1
# 
# }
# 
####################################
# Identifiers
####################################
# set SRC_DIR [getScriptDirectory]
# @600 ns: .
# .
# set TB_MOD "DUT_tb"
# DUT_tb
# set DUT "alu_simple_bugs_enc2"
# alu_simple_bugs_enc2
# set separator "============================================================="
# =============================================================
# set string "Running functional simulation of "
# Running functional simulation of 
# append string ${DUT}
# Running functional simulation of alu_simple_bugs_enc2
# 
####################################
# Compile 
####################################
# onerror {resume}
# transcript on
# 
# if {[file exists work]} {
#     vdel -lib work -all
# }
# 
# vlib work
# vmap work work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work work 
# Modifying modelsim.ini
# 
# "-sv" option enables SV features & keywords; -work specifies logical name/pathname of lib to be mapped
# vlog -sv -work work ${SRC_DIR}/../DUT/${DUT}.svp
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 15:01:04 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./../DUT/alu_simple_bugs_enc2.svp 
# -- Compiling module alu
# ** Warning: ./../DUT/alu_simple_bugs_enc2.svp(19): (vlog-2250) Function "<protected>" has no return value assignment.
# 
# Top level modules:
# 	alu
# End time: 15:01:04 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 1
# vlog -sv -work work ${SRC_DIR}/${TB_MOD}.sv
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 15:01:04 on May 14,2022
# vlog -reportprogress 300 -sv -work work ./DUT_tb.sv 
# -- Compiling module DUT_tb
# 
# Top level modules:
# 	DUT_tb
# End time: 15:01:04 on May 14,2022, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ns -L work ${TB_MOD} 
# vsim -t 1ns -L work $entity 
# End time: 15:01:04 on May 14,2022, Elapsed time: 0:00:31
# Errors: 0, Warnings: 0
# vsim -t 1ns -L work DUT_tb 
# Start time: 15:01:04 on May 14,2022
# Loading sv_std.std
# Loading work.DUT_tb
# Loading work.alu
# -do "T1 T2 T3 # do option doesnt work"
# 
# do wave.do
# onerror {resume}
# quietly WaveActivateNextPane {} 0
# add wave -noupdate -radix binary /DUT_tb/DUT/clk
# add wave -noupdate -radix binary /DUT_tb/DUT/reset
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_a_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_b_in
# add wave -noupdate /DUT_tb/DUT/alu_opcode_in
# add wave -noupdate -radix hexadecimal /DUT_tb/DUT/alu_y_out
# add wave -noupdate -radix binary /DUT_tb/DUT/alu_co_out
# TreeUpdate [SetDefaultTree]
# WaveRestoreCursors {{Cursor 1} {90 ns} 0}
# quietly wave cursor active 1
# configure wave -namecolwidth 200
# configure wave -valuecolwidth 100
# configure wave -justifyvalue left
# configure wave -signalnamewidth 0
# configure wave -snapdistance 10
# configure wave -datasetprefix 0
# configure wave -rowmargin 4
# configure wave -childrowmargin 2
# configure wave -gridoffset 0
# configure wave -gridperiod 1
# configure wave -griddelta 40
# configure wave -timeline 0
# configure wave -timelineunits ns
# update
# WaveRestoreZoom {0 ns} {949 ns}
# 
####################################
# Simulation 
####################################
# puts "\n\n\n\n\n\n\n\n"
# echo \n\n\n\n\n\n\n\n
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @0 ns: =============================================================
# printTxt $string
# @0 ns: Running functional simulation of alu_simple_bugs_enc2
# printTxt $separator
# @0 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# Use variable to keep track of time in simulation and easily iterate previous sequences
# set curTime 0
# 0
# set curTime [expr $curTime + 10]
# 10
# run ${curTime}ns
# getArgs
# @10 ns: Number of arguments: 3
# Arguments are: 
# @10 ns: inside foreach
# @10 ns: --
# @10 ns: Inside switch statement
# @10 ns: Arg1: 4
# @10 ns: Arg2: 5
# @10 ns: Arg3: 6
# @10 ns: argv is: --
# printTxt $architecture
# @10 ns: 
# printTxt $configuration
# @10 ns: 
# printTxt $entity
# @10 ns: DUT_tb
#printTxt $1
#printTxt $2
#printTxt $argc
#printTxt $curTime
# 
# assert reset
# force -deposit sim:/DUT_tb/DUT/reset 1 0
# set curTime [expr $curTime + 20]
# 30
# run @${curTime}ns 
# 30ns
#printTxt $curTime
# 
# demonstrating force with deposit option; note: deposit will drive a value and hold it until it is overwritten by anything
# WIP: not sure if syntax works for abs time
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 35
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 @${curTime}ns 
# set curTime [expr $curTime + 5]
# 40
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 @${curTime}ns 
# 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 0 {@30ns}
# force -deposit sim:/DUT_tb/DUT/alu_b_in 0 {@35ns}
# force -deposit sim:/DUT_tb/DUT/alu_opcode_in 0 {@40ns}
# run {@ 50 ns}
# 
# run {@200ns}
# force -deposit sim:/DUT_tb/DUT/reset 0 
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 
# set string "Deasserting reset, running simulation for addition"
# Deasserting reset, running simulation for addition
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt $separator
# @200 ns: =============================================================
# printTxt $string
# @200 ns: Deasserting reset, running simulation for addition
# printTxt $separator
# @200 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# printTxt "simple case"
# @200 ns: simple case
# 
# freeze will drive a value that cannot be overriden by simulation
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'hff {@210ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'hff {@210ns}
# run {@210ns}
# note: printTxt() displays instantly; need to print after run statement
# printTxt "Carry out asserted case" 
# @210 ns: Carry out asserted case
# 
# This will overwrite the freeze BUT cannot do from tb
# force -deposit sim:/DUT_tb/DUT/alu_a_in 8'd5 {@220ns} 
# force -deposit sim:/DUT_tb/DUT/alu_b_in 8'd4 {@220ns}
# 
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@220ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'd15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h15 {@230ns}
# force -freeze sim:/DUT_tb/DUT/alu_a_in 8'h0 {@240ns}
# force -freeze sim:/DUT_tb/DUT/alu_b_in 8'h0 {@240ns}
# run {@250ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for multiplication"
# Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# printTxt $string
# @250 ns: Running simulation for multiplication
# printTxt $separator
# @250 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h4 {@280ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@250ns}
# run {@280ns}
# printTxt "simple case"
# @280 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@320ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@320ns}
# run {@350ns}
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'hFF {@350ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd2 {@350ns}
# run {@350ns}
# printTxt "simple case"
# @350 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 {@375ns}
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd0 {@375ns}
# run {@375ns}
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h0 0
# run {@420ns}
# 
# puts "\n\n"
# echo \n\n
# 
# 
# 
# set string "Running simulation for division"
# Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# printTxt $string
# @420 ns: Running simulation for division
# printTxt $separator
# @420 ns: =============================================================
# puts "\n\n"
# echo \n\n
# 
# 
# 
# 
# force sim:/DUT_tb/DUT/alu_a_in 8'h0F 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h03 0
# force sim:/DUT_tb/DUT/alu_opcode_in 4'd3 0 
# run {@430ns}
# printTxt "simple case"
# @430 ns: simple case
# force sim:/DUT_tb/DUT/alu_a_in 8'h0 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h1 0
# force sim:/DUT_tb/DUT/alu_a_in 8'h08 {@450ns} 
# force sim:/DUT_tb/DUT/alu_b_in 8'h04 {@450ns}
# run {@510ns}
# printTxt "complex case"
# @510 ns: complex case
# force sim:/DUT_tb/DUT/alu_a_in 8'hFF 0
# force sim:/DUT_tb/DUT/alu_b_in 8'h25 0
# run {@600ns}
